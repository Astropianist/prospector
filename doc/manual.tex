\documentclass[12pt, letterpaper, preprint]{aastex}

\newcommand{\prospector}{Prospector}

\begin{document}

\section{Summary}

\section{Installation \& Requirements}
You will need:

\begin{itemize}
\item \texttt{numpy} and \texttt{scipy}
\item \texttt{emcee}
\item \texttt{FSPS} and \texttt{python-FSPS}
\item \texttt{sedpy} (for nonparametric SFHs)
\item \texttt{MPI} and \texttt{mpi4py} (for parallel processing)
\end{itemize}

Then just git clone the repo and make sure it is somewhere in your
python path.  \prospector is pure python.

\section{User Interaction}
The primary user interaction is through a ``parameter file'', a python
file in which several variables and functions must be defined. Command
line syntax calls the prospector script as an executable and is as
follows for single thread execution:
\begin{center}
\texttt{cd demo} \\
\texttt{python prospectr.py --param\_file=demo\_params.py}
\end{center}
Additional command line options can be given (see \S
\ref{sec:advanced} below). The required variables and functions in
\texttt{demo\_params.py} are
\begin{itemize}
\item {\bf run\_params} A dictionary
\item {\bf load\_obs} A function
\item {\bf load\_model} A function
\item {\bf load\_gp} A function
\item {\bf model\_params} A list of dictionaries
\item {\bf sps} An object
\end{itemize}

See \texttt{tests.sh} and the parameter files and prospectr.py
script in the ``demo'' directory of the repository for more examples
of proper usage.

\subsection{The \emph{run\_params} dictionary}
The following parameters conrol key aspects of the operation of the
code, and are stored in a special dictionary called {\bf run\_params}

\begin{itemize}
\item {\it verbose} Boolean
\item {\it debug} Boolean
\item {\it outfile} string

\item {\it nwalkers} integer
\item {\it nburn} list of integers
\item {\it niter} integer

\item {\it initial\_disp} float
\item {\it do\_powell} Boolean
\item {\it ftol} float
\item {\it maxfev} integer


\item {\it logify\_data} optional Boolean
\item {\it rescale} Boolean
\item {\it normalize\_spectrum} optional Boolean
\item {\it norm\_band\_name} string

\item {\it filename} string
\end{itemize}

The run params dictionary is passed as keyword arguments to the
{\bf load\_obs} and {\bf load\_model} functions, so you can add to it if you want
additional parameters to control the output of these functions.

There is limited support for command line overrides of the {\bf
run\_params} dictionary values. For example
\texttt{python prospectr.py --param\_file=demo\_params.py
  --nwalkers=128}
will cause the code to use 128 walkers regardless of the value given
directly in the {\bf run\_params} dictionary.  Such overriden
parameters must be present as keys in the {\bf run\_params} dictionary,
and they will be coerced to have the same data type as the default
value in the {\bf run\_params} dictionary.

\subsection{The {\bf load\_obs} function}
The code expects a {\bf load\_obs()} method that returns a dictionary
(here called the {\it obs} dictionary) with at least the following
keys:
\begin{itemize}
\item {\it wavelengths}
\item {\it spectrum}
\item {\it unc}
\item {\it mask}
\item {\it filters}
\item {\it maggies}
\item {\it maggies\_unc}
\item {\it phot\_mask}
\end{itemize}

The {\bf load\_obs} function takes arguments from the {\bf run\_params}
dictionary and produces the {\it obs} dictionary.  If you do not have
spectral or photometric data, set {\it spectrum}=\texttt{None} or
{\it maggies}=\texttt{None} respectively.

\subsection{The Model}

\subsubsection{The {\bf load\_model} method}
This should return an instance of a subclass of the
\texttt{bsfh.sedmodel.ThetaParameters} object.  It is given the {\bf
run\_params} dictionary as an argument list, so the model can be
modified based on parameters given here (or at the command line).

\subsubsection{ The {\bf model\_params} list}
On instantiation, a \texttt{bsfh.sedmodel.ThetaParameters} object
takes a list of parameter descriptions that are used to define the
model.  Each model parameter is given an entry in a list called {\bf
model\_params}. Each list element is a dictionary which contains at
minimum the keys {\it name, N, init, isfree} with values giving the
parameter name, number of elements or length of the parameter
($1$ for a scalar), initial value(s), and a boolean specifying
whether the parameter is allowed to vary or not.  Note that the value
of {\it init} can be a numpy array or list if {\it N}$>1$.

For parameters with {\it isfree}=\texttt{True} the following
additional keys of the dictionary are required: {\it prior\_function}
and {\it prior\_args} with values consisting of a the prior function
(e.g. \texttt{tophat}) and a dictionary of arguments to the prior
function. It's also a good idea to have a {\it units} key, and maybe a
{\it label} key, which are strings describing the units of the the
parameter and the name of the parameter to use in plotting.

All the model parameters will be passed to the model object on
instantiation.  The free parameters will be varied by the code during
the optimization and sampling phases.  The initial value from which
optimization is begun is set by the {\it init} values of each
parameter.  For fixed parameters the {\it init} value gives the value
of that parameter that will be used during the optimization and MCMC
phases (unless the {\it depends\_on} key is present, see below.)

Nearly all parameters used by FSPS can be set here.  The default FSPS
parameter values will be used unless specified in a fixed parameter,
e.g. {\it imf\_type} can be changed by including it as a fixed
parameter with value given by {\it init}.

\subsection{The {\bf load_gp} function}
This function should return a GaussianProcess object for the
spectroscopy or photometry.  Either or both can be \texttt{None} in
which case the likelihood will not include covariant noise.

\subsection{The {\bf sps} object}
The likelihood function and SED models take a stellar population ({\bf
sps}) object as an argument.  The stellar population object generally
includes all the spectral libraries necessary to build a model, as
well as some model building code. This object is defined globally to
enable multiprocessing, since it can't (or shouldn't) generally be
serialized and sent to other processors.

The {\bf sps} object must be defined in the parameter file, e.g. 

\begin{center}
\texttt{sps=fsps.StellarPopulation(compute\_vega\_mags=False)}
\end{center}

The SSP and `non-parameteric' SFHs (\texttt{SedModel}) rely on a
\texttt{StellarPopBasis()} object described in the \texttt{sps\_basis}
module.  The composite or parameteric SFHs (\texttt{CSPModel}) rely on
the \texttt{StellarPopulation()} object in the \texttt{fsps} module.
Depending on the model you are using, one of these should be
instantiated in the variable {\bf sps}.

\section{Advanced Usage}

\subsection{Mock data}
Really this should not be advanced.  Everyone should do mock data
tests.  So we are trying to make it easy.

\subsection{User defined models}
The pre-packaged models suck!  You can do better.  Or, you have stars
instead of stellar populations.  Or spectra of the IGM or planets or
AGN or something. Or Echelle data. What to do?

Subclass \texttt{bsfh.sedmodel.ThetaParameters}.  That's it.  Your new
subclass should have a {\it mean\_model()} and a {\it calibration()}
method that converts a dictionary of parameters into a model spectrum.
You'll have to write those.  Then you should have {\bf load\_model}
return an instance of your new class.

\subsection{Linear Algebra}
This code is slow!  Get better math.

If you are fitting spectra, this code does lots of matrix inversions
as part of the gaussian process.  This is very computationally
intensive, and massive gains can be made by using optimized linear
algebra libraries.

\subsection{MPI}
This code is slow!  Get moar processors.

Install some kind of MPI on your system (openMPI, mpich2, mvapich2),
make sure mpi4py is also installed against this MPI installation, and
use the syntax \texttt{mpirun -np <N> python prospectr.py
--param\_file=<param\_file>} Done.


\subsection{Parameter transfomations}
But I don't want to sample in \texttt{dumb\_parameter}!  Transform to
parameters that are easier to sample in. 

This can be done by making \texttt{dumb\_parameter} fixed ({\it
isfree}=\texttt{False}) and adding another key to the parameter
description, {\it depends\_on}.  The value of {\it depends\_on} is a
function which takes as arguments all the model parameters and returns
the value of \texttt{dumb\_parameter}. This function must take
optional extra keywords (\texttt{**extras}) because the entire
parameter dictionary will be passed to it. Then add another parameter
\texttt{smart\_parameter} to {\bf model\_list} that can vary (and upon
which \texttt{dumb\_parameter} depends).

\end{document}

